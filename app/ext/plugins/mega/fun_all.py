# app/ext/plugins/mega/fun_all.py
from __future__ import annotations

import base64
import binascii
import random
import re
from typing import Callable, Dict, List

import discord
from discord import app_commands
from discord.ext import commands


# ---------- helpers (—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä—ã —Ç–µ–∫—Å—Ç–∞) ----------

SMALLCAPS_MAP = {
    "a": "·¥Ä", "b": " ô", "c": "·¥Ñ", "d": "·¥Ö", "e": "·¥á", "f": "“ì", "g": "…¢",
    "h": " ú", "i": "…™", "j": "·¥ä", "k": "·¥ã", "l": " ü", "m": "·¥ç", "n": "…¥",
    "o": "·¥è", "p": "·¥ò", "q": "«´", "r": " Ä", "s": "s", "t": "·¥õ", "u": "·¥ú",
    "v": "·¥†", "w": "·¥°", "x": "x", "y": " è", "z": "·¥¢"
}
LEET_MAP = str.maketrans({
    "a": "4", "A": "4", "e": "3", "E": "3", "i": "1", "I": "1",
    "o": "0", "O": "0", "s": "5", "S": "5", "t": "7", "T": "7",
    "b": "8", "B": "8", "g": "9", "G": "9",
})

def to_fullwidth(s: str) -> str:
    out = []
    for ch in s:
        o = ord(ch)
        if 0x21 <= o <= 0x7E:
            out.append(chr(o - 0x21 + 0xFF01))
        elif ch == " ":
            out.append("„ÄÄ")
        else:
            out.append(ch)
    return "".join(out)

def to_smallcaps(s: str) -> str:
    return "".join(SMALLCAPS_MAP.get(ch, SMALLCAPS_MAP.get(ch.lower(), ch)) for ch in s)

def to_wide(s: str) -> str:
    return " ".join(list(s))

def to_mock(s: str) -> str:
    out, flip = [], True
    for ch in s:
        if ch.isalpha():
            out.append(ch.upper() if flip else ch.lower())
            flip = not flip
        else:
            out.append(ch)
    return "".join(out)

def to_altcase(s: str) -> str:
    return "".join(ch.upper() if random.random() < 0.5 else ch.lower() for ch in s)

def to_rot13(s: str) -> str:
    def rot(c: str) -> str:
        if "a" <= c <= "z": return chr((ord(c)-97+13)%26+97)
        if "A" <= c <= "Z": return chr((ord(c)-65+13)%26+65)
        return c
    return "".join(rot(c) for c in s)

def to_camel(s: str) -> str:
    parts = re.split(r"[\s_\-]+", s.strip())
    if not parts: return s
    return parts[0].lower() + "".join(p.capitalize() for p in parts[1:])

def to_pascal(s: str) -> str:
    return "".join(p.capitalize() for p in re.split(r"[\s_\-]+", s.strip()) if p)

def to_snake(s: str) -> str:
    return "_".join(re.split(r"[\s\-]+", s.strip().lower()))

def to_kebab(s: str) -> str:
    return "-".join(re.split(r"[\s_]+", s.strip().lower()))

def scramble_letters(s: str) -> str:
    chars = list(s); random.shuffle(chars); return "".join(chars)

def only_initials(s: str) -> str:
    return "".join(w[0] for w in re.split(r"\s+", s.strip()) if w)

def surround(s: str, left: str, right: str | None = None) -> str:
    right = left if right is None else right
    return f"{left}{s}{right}"

def markdown_bold(s: str) -> str: return surround(s, "**")
def markdown_italic(s: str) -> str: return surround(s, "*")
def markdown_underline(s: str) -> str: return surround(s, "__")
def markdown_strike(s: str) -> str: return surround(s, "~~")
def markdown_mono(s: str) -> str: return surround(s, "`")
def markdown_codeblock(s: str) -> str: return f"```\n{s}\n```"
def markdown_quote(s: str) -> str: return "\n".join("> " + line for line in s.splitlines())
def markdown_spoiler(s: str) -> str: return surround(s, "||")

def base64_encode(s: str) -> str:
    return base64.b64encode(s.encode("utf-8")).decode("ascii")
def base64_decode(s: str) -> str:
    try:
        return base64.b64decode(s.encode("ascii")).decode("utf-8", errors="replace")
    except binascii.Error:
        return "‚ö†Ô∏è –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π base64."

def to_binary(s: str) -> str:
    return " ".join(f"{ord(ch):08b}" for ch in s)
def from_binary(s: str) -> str:
    try:
        return "".join(chr(int(b, 2)) for b in s.split())
    except ValueError:
        return "‚ö†Ô∏è –ù–µ–≤–∞–ª–∏–¥–Ω–∞—è –±–∏–Ω–∞—Ä–Ω–∞—è —Å—Ç—Ä–æ–∫–∞."

def to_hex(s: str) -> str:
    return s.encode("utf-8").hex()
def from_hex(s: str) -> str:
    try:
        return bytes.fromhex(s).decode("utf-8", errors="replace")
    except ValueError:
        return "‚ö†Ô∏è –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π hex."

def vowel_swap(s: str) -> str:
    table = {"a":"e","e":"i","i":"o","o":"u","u":"a","A":"E","E":"I","I":"O","O":"U","U":"A"}
    return re.sub(r"[aeiouAEIOU]", lambda m: table[m.group()], s)

def remove_vowels(s: str) -> str:
    return re.sub(r"[aeiouAEIOU]", "", s)

def remove_consonants(s: str) -> str:
    return re.sub(r"[b-df-hj-np-tv-zB-DF-HJ-NP-TV-Z]", "", s)

def hashtagify(s: str) -> str:
    return "#" + re.sub(r"\s+", "", s)

def claptext(s: str) -> str:
    parts = re.split(r"\s+", s.strip())
    return " üëè ".join(p for p in parts if p) or s

def owoify(s: str) -> str:
    s = re.sub(r"[lr]", "w", s)
    s = re.sub(r"[LR]", "W", s)
    faces = ["(„Éª`œâ¬¥„Éª)", "(uwu)", "(^‚Ä¢œâ‚Ä¢^)", "(ÔΩ°‚ô•‚Äø‚ô•ÔΩ°)"]
    return s + " " + random.choice(faces)
def uwuify(s: str) -> str: return owoify(s) + " uwu"

def add_emojis(s: str, left: str, right: str) -> str:
    return f"{left} {s} {right}"


# ---------- Cog —Å /fun –∏ 5 –ø–æ–¥–≥—Ä—É–ø–ø–∞–º–∏ ----------

class FunAll(commands.Cog):
    """–û–¥–Ω–∞ –≥—Ä—É–ø–ø–∞ /fun, –≤ –Ω–µ–π 5 –ø–æ–¥–≥—Ä—É–ø–ø –ø–æ 10 –∫–æ–º–∞–Ω–¥ (–∏—Ç–æ–≥–æ 50)."""

    def __init__(self, bot: commands.Bot):
        self.bot = bot

        self.fun = app_commands.Group(name="fun", description="–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞.")

        self.groups: Dict[str, app_commands.Group] = {
            "text": app_commands.Group(name="text", description="–ë–∞–∑–æ–≤—ã–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è"),
            "format": app_commands.Group(name="format", description="Markdown/—Ä–µ–≥–∏—Å—Ç—Ä/—Å—Ç–∏–ª–∏"),
            "encode": app_commands.Group(name="encode", description="–ö–æ–¥–∏—Ä–æ–≤–∫–∏ –∏ —Ñ–æ—Ä–º–∞—Ç—ã"),
            "memes": app_commands.Group(name="memes", description="–ú–µ–º–Ω—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è"),
            "symbols": app_commands.Group(name="symbols", description="–°–∏–º–≤–æ–ª—ã –∏ –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã"),
        }

        # –ø—Ä–∏–∫—Ä—É—á–∏–≤–∞–µ–º –ø–æ–¥–≥—Ä—É–ø–ø—ã –∫ /fun
        for g in self.groups.values():
            self.fun.add_command(g)

        # –¢–æ—á–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ 50 –∫–æ–º–∞–Ω–¥ (5√ó10)
        self._bulk_register("text", [
            ("reverse", "–ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä–æ–∫—É", lambda s: s[::-1]),
            ("upper", "–í –≤–µ—Ä—Ö–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä", str.upper),
            ("lower", "–í –Ω–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä", str.lower),
            ("title", "Title Case", str.title),
            ("mock", "–ß–µ—Ä–µ–¥—É—é—â–∏–π—Å—è —Ä–µ–≥–∏—Å—Ç—Ä (SpOnGeBoB)", to_mock),
            ("altcase", "–°–ª—É—á–∞–π–Ω—ã–π —Ä–µ–≥–∏—Å—Ç—Ä", to_altcase),
            ("wide", "–†–∞—Å—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ–±–µ–ª—ã –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∞–º–∏", to_wide),
            ("fullwidth", "Fullwidth/Ôº∂ÔΩÅÔΩêÔΩèÔΩí", to_fullwidth),
            ("smallcaps", "–ú–∞–ª—ã–µ –∫–∞–ø–∏—Ç–µ–ª–∏ ·¥Ä ô·¥Ñ", to_smallcaps),
            ("rot13", "ROT13", to_rot13),
        ])

        self._bulk_register("format", [
            ("bold", "–ñ–∏—Ä–Ω—ã–π **‚Ä¶**", markdown_bold),
            ("italic", "–ö—É—Ä—Å–∏–≤ *‚Ä¶*", markdown_italic),
            ("underline", "–ü–æ–¥—á—ë—Ä–∫–Ω—É—Ç—ã–π __‚Ä¶__", markdown_underline),
            ("strike", "–ó–∞—á—ë—Ä–∫–Ω—É—Ç—ã–π ~~‚Ä¶~~", markdown_strike),
            ("mono", "–ú–æ–Ω–æ—à–∏—Ä–∏–Ω–Ω—ã–π `‚Ä¶`", markdown_mono),
            ("code", "–ö–æ–¥–æ–≤—ã–π –±–ª–æ–∫ ```", markdown_codeblock),
            ("quote", "–¶–∏—Ç–∞—Ç–∞ > ‚Ä¶", markdown_quote),
            ("spoiler", "–°–ø–æ–π–ª–µ—Ä ||‚Ä¶||", markdown_spoiler),
            ("camel", "camelCase", to_camel),
            ("pascal", "PascalCase", to_pascal),
        ])

        self._bulk_register("encode", [
            ("base64", "Base64 encode", base64_encode),
            ("unbase64", "Base64 decode", base64_decode),
            ("binary", "–í –¥–≤–æ–∏—á–Ω—ã–π", to_binary),
            ("unbinary", "–ò–∑ –¥–≤–æ–∏—á–Ω–æ–≥–æ", from_binary),
            ("hex", "–í hex", to_hex),
            ("unhex", "–ò–∑ hex", from_hex),
            ("snake", "snake_case", to_snake),
            ("kebab", "kebab-case", to_kebab),
            ("initials", "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ–≤", only_initials),
            ("scramble", "–ü–µ—Ä–µ–º–µ—à–∞—Ç—å —Å–∏–º–≤–æ–ª—ã", scramble_letters),
        ])

        self._bulk_register("memes", [
            ("clap", "–¢–µ–∫—Å—Ç —á–µ—Ä–µ–∑ üëè", claptext),
            ("owo", "Owoify", owoify),
            ("uwu", "Uwuify", uwuify),
            ("vowelswap", "–°–¥–≤–∏–≥ –≥–ª–∞—Å–Ω—ã—Ö (a‚Üíe‚Üíi‚Ä¶)", vowel_swap),
            ("novowels", "–£–±—Ä–∞—Ç—å –≥–ª–∞—Å–Ω—ã–µ", remove_vowels),
            ("noconsonants", "–£–±—Ä–∞—Ç—å —Å–æ–≥–ª–∞—Å–Ω—ã–µ", remove_consonants),
            ("hashtag", "–°–¥–µ–ª–∞—Ç—å #—Ö–µ—à—Ç–µ–≥", hashtagify),
            ("e3", "–ó–∞–º–µ–Ω–∏—Ç—å e‚Üí3", lambda s: s.replace("e", "3").replace("E", "3")),
            ("o0", "–ó–∞–º–µ–Ω–∏—Ç—å o‚Üí0", lambda s: s.replace("o", "0").replace("O", "0")),
            ("i1", "–ó–∞–º–µ–Ω–∏—Ç—å i‚Üí1", lambda s: s.replace("i", "1").replace("I", "1")),
        ])

        self._bulk_register("symbols", [
            ("mirror", "–û—Ç—Ä–∞–∑–∏—Ç—å: —Ç–µ–∫—Å—Ç | —Ç—Å–∫–µ—Ç", lambda s: f"{s} | {s[::-1]}"),
            ("repeat2", "–ü–æ–≤—Ç–æ—Ä–∏—Ç—å √ó2", lambda s: (s + " ") * 2),
            ("repeat3", "–ü–æ–≤—Ç–æ—Ä–∏—Ç—å √ó3", lambda s: (s + " ") * 3),
            ("spacestrip", "–£–±—Ä–∞—Ç—å –≤—Å–µ –ø—Ä–æ–±–µ–ª—ã", lambda s: re.sub(r"\s+", "", s)),
            ("spacedouble", "–î–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã", lambda s: re.sub(r"\s+", "  ", s.strip())),
            ("parentheses", "–í —Å–∫–æ–±–∫–∏ (‚Ä¶)", lambda s: f"({s})"),
            ("brackets", "–í –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ [‚Ä¶]", lambda s: f"[{s}]"),
            ("braces", "–í —Ñ–∏–≥—É—Ä–Ω—ã–µ {{‚Ä¶}}", lambda s: f"{{{s}}}"),
            ("hearts", "–î–æ–±–∞–≤–∏—Ç—å ‚ù§Ô∏è", lambda s: add_emojis(s, "‚ù§Ô∏è", "‚ù§Ô∏è")),
            ("fire", "–î–æ–±–∞–≤–∏—Ç—å üî•", lambda s: add_emojis(s, "üî•", "üî•")),
        ])

        # /fun help
        @self.fun.command(name="help", description="–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å–∞–±–∫–æ–º–∞–Ω–¥ /fun")
        async def _help(interaction: discord.Interaction):
            lines: List[str] = []
            for grp_name, grp in self.groups.items():
                names = ", ".join(f"`{c.name}`" for c in grp.commands)
                lines.append(f"**{grp_name}**: {names}")
            embed = discord.Embed(
                title="–°–ø—Ä–∞–≤–∫–∞ –ø–æ /fun",
                description="\n".join(lines),
                color=discord.Color.blurple(),
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)

    def _bulk_register(self, group_key: str, items: List[tuple[str, str, Callable[[str], str]]]) -> None:
        grp = self.groups[group_key]
        for name, desc, transform in items:
            async def _cb(interaction: discord.Interaction, text: str, _t=transform, _name=name):
                result = _t(text or "")
                embed = discord.Embed(title=f"/fun {group_key} {_name}", color=discord.Color.random())
                in_v = text[:1024] if text else "‚Äî"
                out_v = (result[:3990] + "‚Ä¶") if len(result) > 4000 else (result or "‚Äî")
                embed.add_field(name="–í–≤–æ–¥", value=in_v, inline=False)
                embed.add_field(name="–†–µ–∑—É–ª—å—Ç–∞—Ç", value=out_v, inline=False)
                await interaction.response.send_message(embed=embed)

            cmd = app_commands.Command(name=name, description=desc, callback=_cb)
            grp.add_command(cmd)

    async def cog_load(self) -> None:
        self.bot.tree.add_command(self.fun)

    async def cog_unload(self) -> None:
        try:
            self.bot.tree.remove_command(self.fun.name, type=self.fun.type)
        except Exception:
            pass


async def setup(bot: commands.Bot):
    await bot.add_cog(FunAll(bot))